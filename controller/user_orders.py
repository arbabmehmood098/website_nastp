from firebase_config import auth, db, admin_auth
import uuid
from datetime import datetime, timedelta, time
from flask import jsonify, request

def create_order():
    # Authentication
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization header with Bearer token is required"}), 401

    try:
        token = auth_header.split('Bearer ')[1].strip()
        data = request.get_json()

        # Validate required fields
        required_fields = ['user_id', 'products', 'total_amount']
        if not all(field in data for field in required_fields):
            return jsonify({"error": f"Missing required fields: {', '.join(required_fields)}"}), 400

        # Verify token and get user ID (assuming this is a company token)
        user = auth.get_account_info(token)
        company_auth_id = user['users'][0]['localId']

        # Create order data
        order_data = {
            "order_id": str(uuid.uuid4()),
            "company_auth_id": company_auth_id,
            "user_id": data['user_id'],
            "products": data['products'],  # List of product IDs with quantities
            "total_amount": float(data['total_amount']),
            "status": data.get('status', 'pending'),
            "shipping_address": data.get('shipping_address', {}),
            "billing_address": data.get('billing_address', {}),
            "payment_method": data.get('payment_method', ''),
            "payment_status": data.get('payment_status', 'unpaid'),
            # "created_at": datetime.utcnow().isoformat() + "Z",
            # "updated_at": datetime.utcnow().isoformat() + "Z",
            "notes": data.get('notes', '')
        }

        # Add to database using push() to create unique key
        orders_ref = db.child("siberkoza").child("users").child(data['user_id']).child("orders")
        new_order_ref = orders_ref.push(order_data)

        return jsonify({
            "message": "Order created successfully",
            "order": order_data,
            "order_key": new_order_ref['name']  # Returns the unique key generated by push()
        }), 201

    except Exception as e:
        return jsonify({"error": f"Failed to create order: {str(e)}"}), 500


def change_order_status():
    # Authentication
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization header with Bearer token is required"}), 401

    try:
        token = auth_header.split('Bearer ')[1].strip()
        data = request.get_json()

        # Validate required fields
        required_fields = ['user_id', 'order_id']
        if not all(field in data for field in required_fields):
            return jsonify({"error": f"Missing required fields: {', '.join(required_fields)}"}), 400

        # Verify token and get company auth ID
        user = auth.get_account_info(token)
        company_auth_id = user['users'][0]['localId']

        # Get order reference
        order_ref = db.child("siberkoza").child("users").child(data['user_id']).child("orders").child(data['order_id'])
        order = order_ref.get()

        if not order.val():
            return jsonify({"error": "Order not found"}), 404

        # Verify order ownership
        order_data = order.val()
        if order_data.get('company_auth_id') != company_auth_id:
            return jsonify({"error": "Unauthorized to delete this order"}), 403

        # SOFT DELETE IMPLEMENTATION
        update_data = {
            "status": "cancelled",
            "is_active": False,
            "deleted_at": datetime.utcnow().isoformat() + "Z",
            "deleted_by": company_auth_id
        }

        # Preserve original data while marking as deleted
        db.child("siberkoza").child("users").child(data['user_id']).child("orders").child(data['order_id']).update(update_data)

        return jsonify({
            "message": "Order cancelled successfully",
            "order_id": data['order_id'],
            "user_id": data['user_id'],
            "deletion_time": update_data["deleted_at"]
        }), 200

    except Exception as e:
        print(f"Error cancelling order: {str(e)}")
        return jsonify({
            "error": "Failed to cancel order",
            "details": str(e)
        }), 500

def update_order():
    # Authentication
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization header with Bearer token is required"}), 401

    try:
        token = auth_header.split('Bearer ')[1].strip()
        data = request.get_json()

        # Validate required fields
        required_fields = ['user_id', 'order_id']
        if not all(field in data for field in required_fields):
            return jsonify({"error": f"Missing required fields: {', '.join(required_fields)}"}), 400

        # Verify token and get user ID
        user = auth.get_account_info(token)
        requesting_user_id = user['users'][0]['localId']

        # Reference to the specific order
        order_ref = db.child("siberkoza").child("users").child(data['user_id']).child("orders").child(data['order_id'])
        order = order_ref.get()

        # Check if order exists
        if not order.val():
            return jsonify({"error": "Order not found"}), 404

        # Prepare update data (only allow specific fields to be updated)
        allowed_fields = {
            'status',
            'shipping_address',
            'billing_address',
            'payment_method',
            'payment_status',
            'notes',
            'products',
            'total_amount'
        }

        update_data = {}

        # Add only allowed fields that exist in the request
        for field in allowed_fields:
            if field in data:
                update_data[field] = data[field]

        # Validate status transition if updating status
        if 'status' in update_data:
            current_status = order.val().get('status')
            new_status = update_data['status']
            valid_transitions = {
                'pending': ['processing', 'cancelled'],
                'processing': ['shipped', 'cancelled'],
                'shipped': ['delivered'],
                # Add other valid status transitions as needed
            }

            if current_status in valid_transitions and new_status not in valid_transitions[current_status]:
                return jsonify({
                    "error": f"Invalid status transition from {current_status} to {new_status}",
                    "allowed_transitions": valid_transitions.get(current_status, [])
                }), 400

        # Update the order only if there are fields to update
        if update_data:
            order_ref.update(update_data)
            updated_order = order_ref.get().val()
        else:
            updated_order = order.val()

        return jsonify({
            "message": "Order updated successfully",
            "order": updated_order
        }), 200

    except Exception as e:
        return jsonify({"error": f"Failed to update order: {str(e)}"}), 500

def delete_order():
    # Authentication
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization token required"}), 401

    try:
        # Get and validate input
        token = auth_header.split('Bearer ')[1].strip()
        data = request.get_json()

        if not all(field in data for field in ['user_id', 'order_key']):
            return jsonify({"error": "Missing user_id or order_key"}), 400

        # Verify user
        user = auth.get_account_info(token)
        user_id = data['user_id']
        order_key = data['order_key']
        user_uid = user['users'][0]['localId']

        # Reference paths
        order_path = f"siberkoza/users/{user_id}/orders/{order_key}"
        archive_path = f"siberkoza/archives/orders/{order_key}"

        # Get the current order
        order = db.child(order_path).get().val()
        if not order:
            return jsonify({"error": "Order not found"}), 404

        # Verify ownership
        if order.get('company_auth_id') != user_uid:
            return jsonify({"error": "Unauthorized to delete this order"}), 403

        # Create archive version with proper timestamps
        current_timestamp = int(time.time())  # Unix timestamp
        human_time = datetime.now().isoformat()  # Human-readable format

        archive_data = {
            **order,
            "archived_at": current_timestamp,
            "archived_at_human": human_time,
            "archived_by": user_uid,
            "original_path": order_path,
            "archive_reason": "user_requested_deletion"
        }

        # Atomic operation: create archive then delete original
        updates = {
            archive_path: archive_data,
            order_path: None  # Setting to None deletes the node
        }

        # Perform the atomic update
        db.update(updates)

        # Verify results
        if db.child(order_path).get().val() is not None:
            # If original still exists, clean up archive
            db.child(archive_path).remove()
            raise Exception("Original order was not deleted")

        return jsonify({
            "message": "Order archived and deleted successfully",
            "deleted_order": order_key,
            "archive_path": archive_path,
            "archived_at": current_timestamp,
            "archived_at_human": human_time
        }), 200

    except Exception as e:
        # Attempt restoration if we have the original data
        if 'order' in locals() and 'order_path' in locals():
            try:
                db.child(order_path).set(order)
                if 'archive_path' in locals():
                    db.child(archive_path).remove()
            except Exception as restore_error:
                pass

        return jsonify({
            "error": "Order deletion failed",
            "details": str(e),
            "note": "Attempted to restore original order"
        }), 500

def get_user_orders():
    # Authentication - only check for valid Bearer token
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization token required"}), 401

    try:
        # Verify the token is valid (but don't check user identity)
        token = auth_header.split('Bearer ')[1].strip()
        auth.get_account_info(token)  # This will raise exception if token is invalid

        # Get and validate input
        if not request.is_json:
            return jsonify({"error": "Request must be JSON"}), 400

        data = request.get_json()

        if 'user_id' not in data:
            return jsonify({"error": "user_id is required"}), 400

        user_id = data['user_id']

        # Get all non-deleted orders for the specified user_id
        try:
            orders_ref = db.child("siberkoza/users").child(user_id).child("orders")
            orders_snapshot = orders_ref.get()

            orders = {}
            if orders_snapshot.val():
                for order in orders_snapshot.each():
                    order_data = order.val()
                    if order_data.get('status') != 'deleted':
                        orders[order.key()] = order_data

            return jsonify({
                "user_id": user_id,
                "order_count": len(orders),
                "orders": orders
            }), 200

        except Exception as db_error:
            return jsonify({
                "error": "Database operation failed",
                "details": str(db_error)
            }), 500

    except Exception as e:
        return jsonify({
            "error": "Failed to fetch orders",
            "details": str(e)
        }), 500

def get_specific_order():
    # Authentication - only check for valid Bearer token
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization token required"}), 401

    try:
        # Verify the token is valid (but don't check user identity)
        token = auth_header.split('Bearer ')[1].strip()
        auth.get_account_info(token)  # This will raise exception if token is invalid

        # Get and validate input
        if not request.is_json:
            return jsonify({"error": "Request must be JSON"}), 400

        data = request.get_json()

        if not all(field in data for field in ['user_id', 'order_id']):
            return jsonify({"error": "Both user_id and order_id are required"}), 400

        user_id = data['user_id']
        order_id = data['order_id']

        # Get the specific order
        try:
            # Check active orders first
            order_ref = db.child("siberkoza/users").child(user_id).child("orders").child(order_id)
            order = order_ref.get().val()

            if not order:
                # Check archived orders if not found in active
                archived_order = db.child("siberkoza/archives/orders").child(order_id).get().val()
                if archived_order:
                    return jsonify({
                        "message": "Order found in archives",
                        "order": archived_order,
                        "is_archived": True
                    }), 200
                else:
                    return jsonify({"error": "Order not found"}), 404

            # Return order with status indication
            return jsonify({
                "order": order,
                "is_active": order.get('status') != 'deleted',
                "is_archived": False
            }), 200

        except Exception as db_error:
            return jsonify({
                "error": "Database operation failed",
                "details": str(db_error)
            }), 500

    except Exception as e:
        return jsonify({
            "error": "Failed to fetch order",
            "details": str(e)
        }), 500